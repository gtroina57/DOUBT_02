<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   DOUBT ¬∑ Mobile
  </title>
  <style>
  :root {
    --color-bg-gradient-start: #e0eafc;
    --color-bg-gradient-end: #cfdef3;
    --color-white: #ffffff;
    --color-text-main: #102a43;
    --color-blue: #2196f3;
    --color-blue-dark: #0d47a1;
    --color-blue-light: #64b5f6;
    --color-blue-verylight: #e3f2fd;
    --color-shadow-light: rgba(33,150,243,0.08);
    --color-shadow-medium: rgba(33,150,243,0.10);
    --color-shadow-heavy: rgba(33,150,243,0.12);
    --color-placeholder: #90a4ae;
  }

  body {
    background: linear-gradient(135deg, var(--color-bg-gradient-start), var(--color-bg-gradient-end));
    font-family: 'Segoe UI', 'Helvetica Neue', sans-serif;
    color: var(--color-text-main);
    margin: 0;
    padding: 0;
  }

  h1, h2 {
    text-align: center;
    margin-top: 6px;
  }

  h1 {
    color: var(--color-blue-dark);
    letter-spacing: 8px;
    font-size: 4.5rem;
    font-weight: bold;
    text-shadow: 1px 2px 8px var(--color-shadow-medium);
    margin-bottom: 3px;
  }

  h2 {
    color: var(--color-blue-dark);
    font-size: 2.25rem;
    letter-spacing: 2px;
    font-weight: bold;
    margin-bottom: 3px;
  }

  h3 {
    color: var(--color-blue-dark);
    margin-top: 6px;
    margin-bottom: 3px;
    text-align: flex-start;
  }

  .container {
    max-width: 1200px;
    margin: 0 auto 12px auto;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #90caf9;
    border-radius: 24px;
    padding: 28px 34px 32px 34px;
    box-shadow: 0 4px 24px var(--color-shadow-medium);
  }

  .input-row {
    display: flex;
    justify-content: flex-start;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 6px;
  }

  select, select#configSelector {
    padding: 10px;
    border-radius: 6px;
    border: 1.5px solid var(--color-blue);
    font-size: 1rem;
    background-color: var(--color-blue-verylight);
    min-width: 180px;
    font-weight: 500;
    box-shadow: 0 1px 5px var(--color-shadow-light);
  }

  input[type="text"] {
  background: var(--color-white);
  border: 1.5px solid var(--color-blue-light);
  border-radius: 6px;
  padding: 8px 12px;         /* smaller vertical padding = less height */
  font-size: 1rem;
  box-shadow: 0 1px 5px var(--color-shadow-light);
  outline: none;
  transition: border 0.15s;
  min-width: 240px;
  max-width: 1110px;          /* allow wider field */
  flex: 1 1 480px;           /* grow to fill space */
  height: 40px;              /* set exact height */
}

  input[type="text"]:focus {
    border-color: #1565c0;
  }

  textarea#log {
    display: block;
    margin: 0 0 16px 0;
    border-radius: 8px;
    border: 1.5px solid #90caf9;
    background: #f8fbff;
    color: #234;
    box-shadow: 0 1px 8px rgba(33,150,243,0.06);
    resize: vertical;
    font-size: 1rem;
    width: 100%;
    max-width: 1170px;
    max-height: 180px;
    min-height: 100px;
    padding: 12px;
  }

  textarea#messageInput {
  width: 100%;
  max-width: 870px;
  min-height: 40px;
  padding: 6px 12px;
  font-size: 1rem;
  border: 1.5px solid #2196f3;
  border-radius: 6px;
  resize: vertical; /* allows resizing */
  box-shadow: 0 1px 5px rgba(33,150,243,0.08);
  outline: none;
  transition: border 0.15s;
  line-height: 1.4;
}

  button {
    min-width: 120px;
    max-width: 220px;
    padding: 8px 12px;
    margin: 8px 4px;
    background: linear-gradient(to right, #42a5f5, #1e88e5);
    color: var(--color-white);
    font-weight: bold;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    font-family: 'Segoe UI', 'Arial', sans-serif;
    cursor: pointer;
    transition: background 0.18s, box-shadow 0.18s;
    box-shadow: 0 1px 6px rgba(32, 33, 36, 0.08);
    height: 40px;
  }

  button:hover:not(:disabled),
  button:focus-visible:not(:disabled) {
    background: linear-gradient(to right, #1e88e5, #1976d2);
    box-shadow: 0 2px 12px var(--color-shadow-heavy);
    outline: none;
  }

  button:disabled {
    background-color: #b0bfcf;
    color: #f4f4f4;
    cursor: not-allowed;
  }

  progress#audioProgress {
    display: block;
    margin: 18px auto 0 auto;
    height: 20px;
    width: 400px;
    max-width: 80vw;
    background-color: var(--color-blue-verylight);
    border-radius: 8px;
  }

  ::-webkit-input-placeholder,
  ::-moz-placeholder,
  :-ms-input-placeholder,
  ::placeholder {
    color: var(--color-placeholder);
  }
</style>
 </head>
 <body>
  <h1>
   DOUBT
  </h1>
  <div class="container">
   <h3>
    üéõÔ∏è Configuration
   </h3>
   <div class="input-row">
  <select id="languageSelector" onchange="filterConfigsByLanguage()">
    <option value="EN">English</option>
    <option value="IT">Italiano</option>
  </select>

  <select id="configSelector" onchange="setConfig()">
    <option>Loading...</option>
  </select>

</div>
   <h3>
    üéØ Debate Topic
   </h3>
   <input id="topicInput" placeholder="Enter debate topic..." type="text"/>
   <button onclick="setTopic()">
    Set Topic
   </button>
   <p>
    <strong>
     Agent:
    </strong>
    <span id="currentSpeaker">
     None
    </span>
   </p>
   <p>
    <strong>
     AudioContext:
    </strong>
    <span id="audioStatus">
     unknown
    </span>
   </p>
   <h3>
    üìú Debate Log
   </h3>
   <textarea id="log" readonly=""></textarea>
   <h3>
    üí¨ Your Message
   </h3>
   <input id="messageInput" placeholder="Type your message..." type="text"/>
   <button disabled="" id="sendButton" onclick="sendMessage()">
    Send
   </button>
   <button id="speakButton" onclick="startVoiceInput()" style="background-color:#ff9800; color:white;">
    üéô Voice Input
   </button>
   <button onclick="downloadDebateLog()">üíæ Save Debate</button>
   <progress id="audioProgress" max="1" style="display:none;" value="0">
   </progress>
   <button id="resumeAudioButton" onclick="manualResumeAudio()" style="display: none; background-color: #43a047; color: white; font-weight: bold;">
    üîä Resume Audio
   </button>
  </div>
  <script>
   const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const audioQueue = []; // Each item: { url, agent }
  let isPlaying = false;
  let userEnabledAudio = false;
  let userHasTurn = false;

  const ws = new WebSocket("wss://doubt-02.onrender.com/ws");

  ws.onclose = (event) => {
  log(`üîå WebSocket closed: ${event.code}`);
  setTimeout(() => {
    log("üîÑ Attempting to reconnect...");
    location.reload(); // or recreate the WebSocket connection
  }, 3000);
  };


  function log(message, speaker = "system") {
  const logArea = document.getElementById("log");
  logArea.value += `[${speaker}] ${message}\n`;
  logArea.scrollTop = logArea.scrollHeight;

  debateLog.push({
    timestamp: new Date().toISOString(),
    speaker: speaker,
    message: message
  });
}

  function updateAudioStatus() {
    if (document.getElementById("audioStatus")) {
      document.getElementById("audioStatus").textContent = audioContext.state;
    }
  }

  async function manualResumeAudio() {
    try {
      await audioContext.resume();
      log("üîä Audio manually resumed.");
      updateAudioStatus();
      document.getElementById("resumeAudioButton").style.display = "none";
      if (!isPlaying && audioQueue.length > 0) {
        playNextAudio();
      }
    } catch (e) {
      log("‚ùå Manual resume failed: " + e.message);
    }
  }


  function updateSpeaker(agent) {
    if (document.getElementById("audioStatus")) {
      document.getElementById("audioStatus").textContent = audioContext.state;
    }
  }

  function updateSpeaker(agent) {
    if (document.getElementById("currentSpeaker")) {
      document.getElementById("currentSpeaker").textContent = agent || "None";
    }
  }

  async function enableAudio() {
    try {
      await audioContext.resume();
      userEnabledAudio = true;
      log("üîì AudioContext enabled.");
      updateAudioStatus();
    } catch (err) {
      log("‚ùå Failed to enable audio: " + err.message);
    }
  }

  async function playNextAudio() {
    if (audioQueue.length === 0) {
      isPlaying = false;
      return;
    }

    isPlaying = true;
    const { url, agent } = audioQueue.shift();
    // log(`üîä Playing audio from ${agent}: ${url}`);
    updateSpeaker(agent);

    try {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);

      source.onended = () => {
        // log(`‚úÖ Finished audio for ${agent}`);
        updateSpeaker("None");
        isPlaying = false;
        playNextAudio();
      };

      if (audioContext.state === "suspended") {
        await audioContext.resume();
        updateAudioStatus();
      }

      source.start(0);
    } catch (err) {
      log("‚ùå Error playing audio: " + err.message);
      updateSpeaker("None");
      isPlaying = false;
      playNextAudio();
    }
  }

  window.enqueueAudio = function (url, agent = "Unknown") {
    audioQueue.push({ url, agent });
    if (!isPlaying) {
      playNextAudio();
    }
  };

  ws.onopen = async () => {
    log("‚úÖ Connected to debate server.");
    if (userEnabledAudio && audioContext.state === "suspended") {
      await audioContext.resume();
      updateAudioStatus();
    }
  };

  ws.onmessage = (event) => {
    const data = event.data;

    if (data === "__USER_PROXY_TURN__") {
      log("üé§ Moderator gives you the floor. You may speak now.");
      const msgInput = document.getElementById("messageInput");
      msgInput.disabled = false;
      document.getElementById("sendButton").disabled = false;
      msgInput.focus();
      return;
    }

    if (data.startsWith("__AUDIO_URL__/")) {
      const payload = data.replace("__AUDIO_URL__/", "");
      const [relativePath, agent = "Unknown"] = payload.split("|");
      const audioUrl = "https://doubt-02.onrender.com/" + relativePath;
      // log(`üéµ Received audio from ${agent}: ${audioUrl}`);
      enqueueAudio(audioUrl, agent);
      return;
    }

    log("üì© " + data);
  };

  document.getElementById("messageInput").addEventListener("input", function () {
    const hasText = this.value.trim().length > 0;
    document.getElementById("sendButton").disabled = !hasText;
  });

  function setTopic() {
    const topic = document.getElementById("topicInput").value.trim();
    if (topic && ws.readyState === WebSocket.OPEN) {
      ws.send(`__SET_TASK1__:${topic}`);
      log("üìò Topic sent: " + topic);
    }
  }

  function sendMessage() {
    const input = document.getElementById("messageInput");
    let message = input.value.trim();
    if (!message || ws.readyState !== WebSocket.OPEN) return;
    log("üßë You: " + message);
    userHasTurn = false;
    input.placeholder = "Wait for your turn...";
    ws.send("Giuseppe " + message + " XYZ");
    input.value = "";
    document.getElementById("sendButton").disabled = true;
  }

   function startVoiceInput() {
  if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
    log("‚ùå Speech recognition not supported in this browser.");
    return;
  }

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = new SpeechRecognition();

  recognition.lang = (currentLanguage === "IT") ? "it-IT" : "en-US";
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;

  recognition.onstart = () => {
    log("üé§ Listening...");
  };

  recognition.onerror = (event) => {
    log("‚ùå Voice input error: " + event.error);
  };

  recognition.onresult = (event) => {
    const speechResult = event.results[0][0].transcript.trim();
    log("üó£ You said: " + speechResult, "Giuseppe");
    document.getElementById("messageInput").value = speechResult;
    sendMessage();
  };

  recognition.start();
}

let currentLanguage = "EN";
let allConfigFiles = [];
const debateLog = [];

async function fetchConfigFileList() {
  try {
    const res = await fetch("/list_configs");
    const data = await res.json();
    allConfigFiles = data.configs || [];
    filterConfigsByLanguage();
  } catch (error) {
    log("‚ùå Failed to fetch config list: " + error.message);
  }
}

function filterConfigsByLanguage() {
  currentLanguage = document.getElementById("languageSelector").value;
  const selector = document.getElementById("configSelector");
  selector.innerHTML = "";

  const filtered = allConfigFiles.filter(name =>
    name.endsWith(`${currentLanguage}.json`) || name.endsWith(`${currentLanguage}.JSON`)
  );

  if (filtered.length === 0) {
    const option = document.createElement("option");
    option.textContent = "No config available";
    option.disabled = true;
    selector.appendChild(option);
    return;
  }

  filtered.forEach(name => {
    const option = document.createElement("option");
    option.value = name;
    option.textContent = name;
    selector.appendChild(option);
  });

  selector.value = filtered[0];
  setConfig();
}

async function setConfig() {
  const selected = document.getElementById("configSelector").value;
  if (!selected) return;
  try {
    const res = await fetch("/set_config", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name: selected })
    });
    const result = await res.json();
    log("üõ†Ô∏è Config selected: " + result.selected, "system");
  } catch (e) {
    log("‚ùå Config set error: " + e.message, "system");
  }
}
    window.onload = () => {
  fetchConfigFileList();
};


  // Periodic ping
  setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send("__ping__");
    }
  }, 20000);

  // Resume on visibility change
  document.addEventListener("visibilitychange", async () => {
    if (document.visibilityState === "visible" && audioContext.state === "suspended") {
      await audioContext.resume();
      log("üîÅ Resumed AudioContext after visibility change.");
      updateAudioStatus();
    }
  });

  // Watchdog for stalled audio
  
  setInterval(() => {
  if (!isPlaying && audioQueue.length > 0 && userEnabledAudio) {
    log("üîÅ Watchdog restarting audio.");
    playNextAudio();
  }

  // Force resume attempt to detect suspension
  if (userEnabledAudio) {
    audioContext.resume().then(() => {
      document.getElementById("resumeAudioButton").style.display = "none";
      updateAudioStatus();
    }).catch(() => {
      document.getElementById("resumeAudioButton").style.display = "block";
      log("‚ö†Ô∏è AudioContext likely suspended ‚Äî tap 'Resume Audio' to continue.");
    });
  }
}, 5000);

  // Start audio system

  document.addEventListener("click", () => {
  audioContext.resume().then(() => {
    log("üîì AudioContext resumed after user tap.");
    updateAudioStatus();
  });
  }, { once: true });

  enableAudio();

function downloadDebateLog() {
  const blob = new Blob([JSON.stringify(debateLog, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `debate_${new Date().toISOString().replace(/[:.]/g, "-")}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

  </script>
 </body>
</html>
